#+title: Emacs Literate Config
#+author: Teia Leusten
#+description: Teia Leusten's personal Emacs config.
#+startup: overview

#+begin_src emacs-lisp
;;; -*- lexical-binding: t -*-
#+end_src

* PACKAGE MANAGEMENT
** Install elpaca

First, let's install Elpaca itself. This following snippet is taken directly from the Elpaca [[https://github.com/progfolio/elpaca][github]].
#+begin_src emacs-lisp
  (defvar elpaca-installer-version 0.11)
  (defvar elpaca-directory (expand-file-name "elpaca/" user-emacs-directory))
  (defvar elpaca-builds-directory (expand-file-name "builds/" elpaca-directory))
  (defvar elpaca-repos-directory (expand-file-name "repos/" elpaca-directory))
  (defvar elpaca-order '(elpaca :repo "https://github.com/progfolio/elpaca.git"
                                :ref nil :depth 1 :inherit ignore
                                :files (:defaults "elpaca-test.el" (:exclude "extensions"))
                                :build (:not elpaca--activate-package)))
  (let* ((repo  (expand-file-name "elpaca/" elpaca-repos-directory))
         (build (expand-file-name "elpaca/" elpaca-builds-directory))
         (order (cdr elpaca-order))
         (default-directory repo))
    (add-to-list 'load-path (if (file-exists-p build) build repo))
    (unless (file-exists-p repo)
      (make-directory repo t)
      (when (<= emacs-major-version 28) (require 'subr-x))
      (condition-case-unless-debug err
          (if-let* ((buffer (pop-to-buffer-same-window "*elpaca-bootstrap*"))
                    ((zerop (apply #'call-process `("git" nil ,buffer t "clone"
                                                    ,@(when-let* ((depth (plist-get order :depth)))
                                                        (list (format "--depth=%d" depth) "--no-single-branch"))
                                                    ,(plist-get order :repo) ,repo))))
                    ((zerop (call-process "git" nil buffer t "checkout"
                                          (or (plist-get order :ref) "--"))))
                    (emacs (concat invocation-directory invocation-name))
                    ((zerop (call-process emacs nil buffer nil "-Q" "-L" "." "--batch"
                                          "--eval" "(byte-recompile-directory \".\" 0 'force)")))
                    ((require 'elpaca))
                    ((elpaca-generate-autoloads "elpaca" repo)))
              (progn (message "%s" (buffer-string)) (kill-buffer buffer))
            (error "%s" (with-current-buffer buffer (buffer-string))))
        ((error) (warn "%s" err) (delete-directory repo 'recursive))))
    (unless (require 'elpaca-autoloads nil t)
      (require 'elpaca)
      (elpaca-generate-autoloads "elpaca" repo)
      (let ((load-source-file-function nil)) (load "./elpaca-autoloads"))))
  (add-hook 'after-init-hook #'elpaca-process-queues)
  (elpaca `(,@elpaca-order))
#+end_src

** Enable use-package support

It is just more convenient to use ~use-package~ declarations, since allmost all package recipes provide them.
#+begin_src emacs-lisp
  (elpaca elpaca-use-package
    (elpaca-use-package-mode))
#+end_src

** Auto-update packages

Run auto-update periodically.
#+begin_src emacs-lisp
  (use-package auto-package-update
    :ensure t
    :custom
    (auto-package-update-interval 7)
    (auto-package-update-delete-old-versions t)
    (auto-package-update-hide-results t)
    (auto-package-update-prompt-before-update t)
    :config
    (auto-package-update-maybe))
#+end_src

* GENERAL KEYS

General and its keybindings. The keybindings here all begin with a leader key. Everything else related to particular
packages is defined in the respecitive ~use-package~ block and uses Emacs-style prefixes.
#+begin_src emacs-lisp
    (use-package general
      :ensure t
      :demand t
      :config
      ;; Set up '\' as the global leader key
      (general-create-definer tl/leader
        :states '(normal insert visual emacs)
        :keymaps 'override
        :prefix ","
        :global-prefix "M-,")

      ;; Config
      (tl/leader
        "f c" '(:ignore t :wk "config")
        "f c c" '((lambda () (interactive) (find-file "~/.config/emacs/config.org")) :wk "config.org")
        "f c i" '((lambda () (interactive) (find-file "~/.config/emacs/init.el")) :wk "init.el")
        "f c e" '((lambda () (interactive) (find-file "~/.config/emacs/early-init.el")) :wk "early-init.el")
        "f c r" '((lambda ()
                    (interactive)
                    (load-file "~/.config/emacs/init.el"))
                  :wk "reload config"))

      ;; Buffers
      (tl/leader
        "b" '(:ignore t :wk "buffers")
        "b s" '(mode-line-other-buffer :wk "swap recent")
        "b i" '(ibuffer :wk "ibuffer")
        "b b" '(switch-to-buffer :wk "switch")
        "b k" '(kill-buffer :wk "kill"))

      ;; Files
      (tl/leader
        "f" '(:ignore t :wk "files")
        "f f" '(find-file :wk "find file")
        "f u" '(sudo-edit-find-file :wk "find file as root")
        "f U" '(sudo-edit :wk "edit file as root"))

      ;; Org mode
      (tl/leader
        "o" '(:ignore t :wk "org")
        "o a" '(:ignore t :wk "attachments")
        "o a a" '(org-attach-attach :wk "attach")
        "o a o" '(org-attach-open :wk "open")
        "o a O" '(org-attach-open-in-emacs :wk "open here")
        "o t" '(org-todo :wk "todo")
        "o b" '(:ignore t :wk "board")
        "o b a" '(tl/org-board-archive-heading-url :wk "archive")
        "o b o" '(org-board-open :wk "open")
        "o l" '(org-insert-link :wk "link")
        "o s" '(org-schedule :wk "schedule")
        "o d" '(org-deadline :wk "deadline")
        "o h" '(:ignore t :wk "effort")
        "o e e" '(org-set-effort :wk "set effort")
        "o e r" '(tl/org-register-pomodoro :wk "register pomodoro")
        "o h" '(:ignore t :wk "habits")
        "o h h" '(tl/org-make-habit :wk "new habit")
        "o h p" '(tl/org-postpone-habit-by-one-day :wk "postpone")
        "o f" '(tl/refile-from-inbox :wk "refile")
        "o c" '(org-capture :wk "capture")
        "o r" '((lambda () (interactive) (org-update-statistics-cookies t) (org-agenda-redo-all)) :wk "refresh"))

      ;; Denote
      (tl/leader
        "d" '(:ignore t :wk "denote")
        "d s" '(:ignore t :wk "search")
        "d s s" '(denote-dired :wk "search all")
        "d s a" '((lambda () (interactive) (denote-dired "_area" "title" nil nil)) :wk "areas")
        "d s p" '((lambda () (interactive) (denote-dired "_project" "title" nil nil)) :wk "projects")
        "d s b" '((lambda () (interactive) (denote-dired "_book" "title" nil nil)) :wk "books")
        "d s c" '((lambda () (interactive) (denote-dired "_course" "title" nil nil)) :wk "courses")
        "d s n" '((lambda () (interactive) (denote-dired "_channel" "title" nil nil)) :wk "channels")
        "d n" '(denote :wk "new denote")
        "d l" '(denote-link :wk "link")
        "d L" '(denote-add-links :wk "add links")
        "d h" '(denote-org-link-to-heading :wk "link to heading")
        "d b" '(denote-backlinks :wk "backlinks")
        "d r" '(denote-rename-file :wk "rename")
        "d R" '(denote-rename-file-using-front-matter :wk "rename with tags")
        "d i" '((lambda () (interactive) (find-file (expand-file-name "inbox.org" tl/org-path))) :wk "inbox")
        "d j" '(:ignore t :wk "journal")
        "d j n" '(denote-journal-new-entry :wk "new")
        "d j j" '(denote-journal-new-or-existing-entry :wk "new or existing")
        "d j l" '(denote-journal-link-or-create-entry :wk "link or create"))

      ;; Emacs help system
      (tl/leader
        "h" '(:ignore t :wk "help")
        "h q" '(help-quick-toggle :wk "quick help")
        "h i" '(info :wk "info")
        "h d" '(:ignore t :wk "describe")
        "h d m" '(describe-mode :wk " mode")
        "h d x" '(desctibe-command :wk "command")
        "h d f" '(describe-function :wk "function")
        "h d v" '(desctibe-variable :wk "variable")
        "h d k" '(desctribe-key :wk "key")
        "h a" '(:ignore t :wk "apropos")
        "h a a" '(apropos :wk "all")
        "h a c" '(apropos-command :wk "commands")
        "h a d" '(apropos-documentation :wk "docstrings")
        "h a l" '(apropos-library :wk "library")
        "h a v" '(apropos-value :wk "value"))

      ;; Toggles
      (tl/leader
        "t" '(:ignore t :wk "toggle")
        "t l" '(display-line-numbers-mode :wk "line numbers")
        "t r" '(visual-line-mode :wk "truncated lines")
        "t m" '(global-visible-mark-mode :wk "visible marks")
        "t t" '(org-tidy-toggle :wk "org property drawers")))
#+end_src

* BASIC INFORMATION
** Identity

Identity information used by some programs like GPG and mail clients.
#+begin_src emacs-lisp
  (setq user-full-name "Teia Lesuten")
  (setq user-mail-address "teia.leusten@proton.me")
#+end_src

** Directories

Various directories used by the system.
#+begin_src emacs-lisp
  (defvar tl/org-path "~/Drive/"
    "Directory for org notes.")
  (defvar tl/org-areas-path (file-name-concat tl/org-path "areas/")
    "Subdirectory for area notes.")
  (defvar tl/org-journal-path (file-name-concat tl/org-path "journal/")
    "Subdirectory for my journal.")
  (defvar tl/org-projects-path (file-name-concat tl/org-path "projects/")
    "Subdirectory for project notes.")
  (defvar tl/org-resources-path (file-name-concat tl/org-path "resources/")
    "Subdirectory for resouces.")
  (defvar tl/org-attachments-path (file-name-concat tl/org-path "attachments/")
    "Subdirectory for attachments.")
#+end_src

* CODING & LANGUAGES
** Rainbow delimiters

Visually matched delimiters.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :ensure t
    :hook
    (prog-mode-hook . rainbow-delimiters-mode))
#+end_src

** Prism

Beuatiful delimiters and blocks colored by depth. I use this as a toggle to analzy highly nested code, because it
overlays the theme formatting.
#+begin_src emacs-lisp :tangle no
  (use-package prism
    :ensure (:fetcher github :repo "alphapapa/prism.el"))
#+end_src

** Clojure

Install CIDER.
#+begin_src emacs-lisp
(use-package cider
  :ensure t)
#+end_src

* COMPLETION SYSTEM
** Vertico

Vertico provides only completion UI based solely on built-in Emacs facilities.
#+begin_src emacs-lisp
  (use-package vertico
    :ensure t
    :custom
    (vertico-resize t) ;; Grow and shrink the Vertico minibuffer
    (vertico-cycle t)  ;; Enable cycling for `vertico-next/previous'
    :init
    (vertico-mode)
    :bind
    (:map vertico-map
        ("C-j" . vertico-next)
        ("C-k" . vertico-previous)))

  ;; Emacs minibuffer configurations.
  (use-package emacs
    :custom
    ;; Support opening new minibuffers from inside existing minibuffers.
    (enable-recursive-minibuffers t)
    ;; Hide commands in M-x which do not work in the current mode.  Vertico
    ;; commands are hidden in normal buffers. This setting is useful beyond
    ;; Vertico.
    (read-extended-command-predicate #'command-completion-default-include-p)
    ;; Do not allow the cursor in the minibuffer prompt
    (minibuffer-prompt-properties
     '(read-only t cursor-intangible t face minibuffer-prompt)))
#+end_src

** Orderless

Use the `orderless' completion style.
#+begin_src emacs-lisp
  (use-package orderless
    :ensure t
    :custom
    ;; Configure a custom style dispatcher (see the Consult wiki)
    ;; (orderless-style-dispatchers '(+orderless-consult-dispatch orderless-affix-dispatch))
    ;; (orderless-component-separator #'orderless-escapable-split-on-space)
    (completion-styles '(orderless basic))
    (completion-category-defaults nil)
    (completion-category-overrides '((file (styles partial-completion)))))
#+end_src

** Marginalia

Enable rich annotations using the Marginalia package.
#+begin_src emacs-lisp
  (use-package marginalia
    :ensure t
    ;; Bind `marginalia-cycle' locally in the minibuffer.  To make the binding
    ;; available in the *Completions* buffer, add it to the
    ;; `completion-list-mode-map'.
    :bind
    (:map minibuffer-local-map
          ("M-A" . marginalia-cycle))

    ;; Marginalia must be activated in the :init section of use-package such that
    ;; the mode gets enabled right away. Note that this forces loading the
    ;; package.
    :init
    (marginalia-mode))
#+end_src

* DENOTE
** Install denote

Install Denote package.
#+begin_src emacs-lisp
  (use-package denote
    :ensure t
    :hook (dired-mode-hook . denote-dired-mode)
    :bind
    (:map global-map
        ("C-c n n" . denote)
        ("C-c n s" . denote-subdirectory)
        ("C-c n d" . denote-dired)
        ("C-c n g" . denote-grep)
        ;; If you intend to use Denote with a variety of file types, it is
        ;; easier to bind the link-related commands to the `global-map', as
        ;; shown here.  Otherwise follow the same pattern for `org-mode-map',
        ;; `markdown-mode-map', and/or `text-mode-map'.
        ("C-c n q c" . denote-query-contents-link) ; create link that triggers a grep
        ("C-c n q f" . denote-query-filenames-link) ; create link that triggers a dired
        ;; Key bindings specifically for Dired.
        :map dired-mode-map
        ("C-c C-d C-i" . denote-dired-link-marked-notes)
        ("C-c C-d C-r" . denote-dired-rename-files)
        ("C-c C-d C-k" . denote-dired-rename-marked-files-with-keywords)
        ("C-c C-d C-R" . denote-dired-rename-marked-files-using-front-matter))
    :config
    (setq denote-directory tl/org-path)
    (setq denote-save-buffers nil)
    (setq denote-known-keywords '("journal" "book" "course" "channel" "project" "area"))
    (setq denote-infer-keywords t)
    (setq denote-sort-keywords t)
    (setq denote-prompts '(title keywords))
    (setq denote-excluded-directories-regexp nil)
    (setq denote-excluded-keywords-regexp nil)
    (setq denote-rename-confirmations '(rewrite-front-matter modify-file-name))
    (setq denote-date-prompt-use-org-read-date t)
    (denote-rename-buffer-mode 1))
#+end_src

** Install org extensions

This package has a bunch of useful commands that I frequently use, like interactively creating links to headings.
#+begin_src emacs-lisp
  (use-package denote-org
    :ensure t)
#+end_src

** Install journal

Denote journaling comes as a separate package so I need to install and set it up.
#+begin_src emacs-lisp
  (use-package denote-journal
    :ensure t
    :commands (denote-journal-new-entry
               denote-journal-new-or-existing-entry
               denote-journal-link-or-create-entry)
    :hook (calendar-mode-hook . denote-journal-calendar-mode)
    :config
    ;; Use the "journal" subdirectory of the `denote-directory'.  Set this
    ;; to nil to use the `denote-directory' instead.
    (setq denote-journal-directory tl/org-journal-path)
    ;; Default keyword for new journal entries. It can also be a list of
    ;; strings.
    (setq denote-journal-keyword "journal")
    ;; Read the doc string of `denote-journal-title-format'.
    (setq denote-journal-title-format 'day-date-month-year))
#+end_src

** Set up capture system

We need custom front matter for each specific note type.
#+begin_src emacs-lisp
  (defun tl/front-matter-header (category)
    "Return Org front matter string with CATEGORY inserted after filetags line."
    (concat "#+title:      %s\n"
            "#+date:       %s\n"
            "#+filetags:   %s\n"
            (format "#+category:   %s\n" category)
            "#+identifier: %s\n"))

  (defvar tl/front-matter-footer
    (concat "#+startup:    show2levels\n"
            "#+options:    toc:2\n"))

  (defun tl/assemble-front-matter (category &rest contents)
    "Assemble front matter from CATEGORY, HEADER, CONTENTS..., and FOOTER.
      Each CONTENT string will have a newline appended automatically."
    (concat (tl/front-matter-header category)
            (mapconcat #'identity contents "\n")
            tl/front-matter-footer
            "\n"))
#+end_src

** Define capture templates
*** Journal

Set up journal capture template.
#+begin_src emacs-lisp
  (with-eval-after-load 'org-capture
    (add-to-list 'org-capture-templates
                 `("j" "Journal" entry
                   (file denote-journal-path-to-new-or-existing-entry)
                   ,(concat "* ACTIVITY LOG\n%?\n"
                            "* THOUGHTS & IDEAS\n"
                            "* COMPLETED TASKS")
                   :kill-buffer t
                   :empty-lines 1
                   :jump-to-captured t)))
#+end_src

*** Books

Define book capture template.
#+begin_src emacs-lisp
  (defvar tl/book-front-matter
    (tl/assemble-front-matter "resource"
     "#+author:     %%^{Author}"
     "#+year:       %%^{Year}"
     "#+isbn:       %%^{ISBN}"
     "#+url:        %%^{URL}"))

  (defvar tl/book-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
            "* CHAPTERS\n\n"
  	  "* RESOURCES\n\n"
  	  "* LINKS :link:\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("b" "Book" plain
       (file denote-last-path)
       #'(lambda ()
           (let ((denote-use-directory tl/org-resources-path)
                 (denote-use-keywords '("book"))
                 (denote-use-template tl/book-template)
                 (denote-org-front-matter tl/book-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src

*** Courses

Define course capture template.
#+begin_src emacs-lisp
  (defvar tl/course-front-matter
    (tl/assemble-front-matter "resource"
     "#+author:     %%^{Author}"
     "#+provider:   %%^{Provider}"
     "#+url:        %%^{URL}"))

  (defvar tl/course-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
            "* LESSONS\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("c" "Course" plain
       (file denote-last-path)
       #'(lambda ()
           (let ((denote-use-directory tl/org-resources-path)
                 (denote-use-keywords '("course"))
                 (denote-use-template tl/course-template)
                 (denote-org-front-matter tl/course-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src

*** Channels

Define youtube channel capture template.
#+begin_src emacs-lisp
  (defvar tl/channel-front-matter
    (tl/assemble-front-matter "resource"
     "#+url:        %%^{URL}"))

  (defvar tl/channel-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
            "* VIDEOS\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("n" "Channel" plain
       (file denote-last-path)
       #'(lambda ()
           (let ((denote-use-directory tl/org-resources-path)
                 (denote-use-keywords '("channel"))
                 (denote-use-template tl/channel-template)
                 (denote-org-front-matter tl/channel-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src

*** Games

Define youtube channel capture template.
#+begin_src emacs-lisp
  (defvar tl/game-front-matter
    (tl/assemble-front-matter "resource"
     "#+url:        %%^{URL}"))

  (defvar tl/game-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
            "* GUIDES\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("g" "Game" plain
       (file denote-last-path)
       #'(lambda ()
           (let ((denote-use-directory tl/org-resources-path)
                 (denote-use-keywords '("game"))
                 (denote-use-template tl/game-template)
                 (denote-org-front-matter tl/game-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src

*** Projects

Define project capture template.
#+begin_src emacs-lisp
  (defvar tl/project-front-matter
    (tl/assemble-front-matter "project"))

  (defvar tl/project-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
  	  "* HABITS\n"
  	  "* TASKS\n"
            "* RESOURCES\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("p" "Project" plain
       (file denote-last-path)
       #'(lambda ()
         (let ((denote-use-directory tl/org-projects-path)
                 (denote-use-keywords '("project"))
                 (denote-use-template tl/project-template)
                 (denote-org-front-matter tl/project-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src

*** Areas

Define area capture template.
#+begin_src emacs-lisp
  (defvar tl/area-front-matter
    (tl/assemble-front-matter "area"))

  (defvar tl/area-template
    (concat "* TABLE OF CONTENTS :toc:\n"
            "  :PROPERTIES:\n"
            "  :auto-expand: body\n"
            "  :END:\n\n"
  	  "* HABITS\n"
  	  "* TASKS\n"
            "* RESOURCES\n"
            "%?\n\n"))

  (with-eval-after-load 'org-capture
    (add-to-list
     'org-capture-templates
     '("a" "Area" plain
       (file denote-last-path)
       #'(lambda ()
         (let ((denote-use-directory tl/org-areas-path)
                 (denote-use-keywords '("area"))
                 (denote-use-template tl/area-template)
                 (denote-org-front-matter tl/area-front-matter)
                 (denote-org-capture-specifiers nil))
             (denote-org-capture)))
       :no-save t
       :immediate-finish nil
       :kill-buffer t
       :jump-to-captured t)))
#+end_src
* EDITOR CONFIG
** Evil

I tried to get rid of evil but it is impossible. I will stick to the basics, becase I don't want it to be too
intrusive.
#+begin_src emacs-lisp
  (use-package evil
    :ensure t
    :init
    ;; Minimize intrusiveness.
    (setq evil-respect-visual-line-mode t)
    (setq evil-undo-system 'undo-redo)
    (setq evil-want-C-w-delete t)
    (setq evil-want-C-w-in-emacs-state nil)
    (setq evil-want-C-u-scroll nil)                 ;; I rarely use scroll commands in vim, and I need C-u in Emacs.
    (setq evil-want-C-d-scroll nil)                 ;; For consistency disable this too.
    (setq evil-want-C-i-jump nil)                   ;; Retain Emacs C-u.
    (setq evil-toggle-key "C-`")                    ;; Because the deault C-z is to useful to use for evil toggle.
    (with-eval-after-load 'evil
      (define-key evil-normal-state-map (kbd "C-r") 'isearch-backward))

    :config
    (evil-mode)

    ;; Evil-states per major mode
    (setq evil-default-state 'emacs)
    (setq evil-normal-state-modes '(fundamental-mode
                                    ssh-config-mode
                                    conf-mode
                                    prog-mode
                                    text-mode
                                    repos-mode
                                    dired-mode))

    ;; Minor mode evil states
    (add-hook 'with-editor-mode-hook 'evil-insert-state)
    (add-hook 'git-commit-setup-hook 'evil-insert-state) ;; Start editing Magit in insert state.

    ;; Disable evil in some modes.
    (evil-set-initial-state 'eat-mode 'emacs)
    (evil-set-initial-state 'calendar-mode 'emacs))
#+end_src

** Visible marks

Enable visible marks.
#+begin_src emacs-lisp
  (require 'color) ;; for `color-rgb-to-hex` and `color-hsl-to-rgb`

  (defvar tl/visible-mark-palette
    '("#800000" "#c23232" "#cd5c5c" "#f4a460" "#eab700")
    "Palette from dark red to light yellow for visible mark faces.")

  (defun tl/jump-to-mark ()
    "Jump to the most recent mark, like `C-u C-SPC`."
    (interactive)
    (set-mark-command 4))

  (use-package visible-mark
    :ensure (:fetcher github :repo "emacsmirror/visible-mark")
    :init
    (let ((colors tl/visible-mark-palette))
      (setq visible-mark-faces
            (cl-loop for i from 1 to (length colors)
                     for color in colors
                     collect
                     (let ((face-name (intern (format "visible-mark-face%d" i))))
                       (eval `(defface ,face-name
                                '((((type tty) (class mono)))
                                  (t (:foreground ,color :box (:color ,color))))
                                ,(format "Visible mark face %d (magenta fixed)." i)))
                       face-name))))
    (setq visible-mark-max (length tl/visible-mark-palette))
    :config
    (global-set-key (kbd "M-o") #'tl/jump-to-mark)
    (global-visible-mark-mode 1))
#+end_src

* EMACS

Tweaks to Emacs configuration not relared to UI.
#+begin_src emacs-lisp
  (setq show-trailing-whitespace t)    ;; Show trailing whitespace.
  (setq delete-by-moving-to-trash t)   ;; Use trash-cli rather than rm when deleting files.
  (setq sentence-end-double-space nil) ;; Don't use double space to demarkate sentences.
  (setq debug-on-error t)              ;; I'd rather prefer my Emacs config has no errors.
#+end_src

** Backups

Control how backups are made.
#+begin_src emacs-lisp
  ;; keep backup and save files in a dedicated directory
  (setq backup-directory-alist
        `((".*" . ,(file-name-concat user-emacs-directory "backups")))
        auto-save-file-name-transforms
        `((".*" ,(file-name-concat user-emacs-directory "backups") t)))

  ;; Backup by copying file. The safest and also the slowest aproach.
  (setq backup-by-copying t)

  ;; Do more backups.
  (setq delete-old-versions t
        kept-new-versions 6
        kept-old-versions 2
        version-control t)
#+end_src

** Disable customize

Don't persist customizations.
#+begin_src emacs-lisp
  (setq custom-file (make-temp-file "")) ;; Use a temp file as a placeholder.
  (setq custom-safe-themes t)            ;; Mark all themes as safe, since we can't persist now.
#+end_src

** UTF-8 encoding

Use UTF-8 everywhere.
#+begin_src emacs-lisp
  (set-charset-priority 'unicode)
  (setq locale-coding-system 'utf-8
        coding-system-for-read 'utf-8
        coding-system-for-write 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  (set-selection-coding-system 'utf-8)
  (prefer-coding-system 'utf-8)
  (setq default-process-coding-system '(utf-8-unix . utf-8-unix))
#+end_src

** Exit confirmations

Exit emacs without confirmations.
#+begin_src emacs-lisp
  (setq confirm-kill-emacs nil
        confirm-kill-processes nil)
#+end_src

** Fill column

Tweaks to the editing process, like the width of a line etc.
#+begin_src emacs-lisp
  (setq-default fill-column 120)
  (add-hook 'org-mode-hook 'turn-on-auto-fill)
  (add-hook 'org-mode-hook 'display-fill-column-indicator-mode)
  (setq-default display-fill-column-indicator-character ?┊)
  (set-face-attribute 'fill-column-indicator nil :foreground "grey90")
#+end_src

** Disable toolbar and scrollbar

Disable the ugly UI but leave menu bar intact because on macs it is not intrusive.
#+begin_src emacs-lisp
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (tooltip-mode -1)
#+end_src

** Disable sound

Removing audio distractions. Why would anyone even leave it on?
#+begin_src emacs-lisp
  (setq ring-bell-function 'ignore)
#+end_src

** Display line numbers and truncated lines

Line numbers are essential for any vim-controlled work.
#+begin_src emacs-lisp
  (setq display-line-numbers-type 'visual)
  (setq display-line-numbers-width-start t)
  (global-display-line-numbers-mode 1)
  (global-visual-line-mode 1)
#+end_src

** Specify Emacs frame size and position

This part of configuration is specific to my home notebook, Calypso.
#+begin_src emacs-lisp
  (setq default-frame-alist
    '((top . 51)
      (left . 200)
      (width . 182)
      (height . 51)))
#+end_src

** Remove window decorations

Remove the title bar, it looks rather ugly to me, and we need as much screen estate as possible to squeeze out my
small monitor. I also like the squarish look of the window and in general dislike rounded corners everywhere.
#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(undecorated . t))
#+end_src

** Enable transparency

I like seeing my wallpapers.
#+begin_src emacs-lisp
  (set-frame-parameter (selected-frame) 'alpha '(85 . 85))
  (add-to-list 'default-frame-alist '(alpha . (85 . 85)))
#+end_src

** Add small margins around the frame

Add some breathing room for the text.
#+begin_src emacs-lisp
  (modify-all-frames-parameters '((internal-border-width . 8)))
#+end_src

** Enable line and column highlights

Enable global hl mode. Dark themes with low contract like the one I'm using make it hard to locate the cursor.
#+begin_src emacs-lisp
  (global-hl-line-mode)
#+end_src

** Scrolling

Leave some margin after recentering.
#+begin_src emacs-lisp
  (setq scroll-margin 3)
#+end_src

** Other minor tweaks

An assortment of other minor tweaks to Emacs UI.
#+begin_src emacs-lisp
  (blink-cursor-mode -1)        ; Steady cursor
  (pixel-scroll-precision-mode) ; Smooth scrolling
  (global-set-key (kbd "<escape>") 'keyboard-escape-quit) ; ESC quits prompts
#+end_src

* FILES & FORMATS
** Sudo-edit

sudo-edit gives us the ability to open files with sudo privileges or switch over to editing with sudo privileges if
we initially opened the file without such privileges.
#+begin_src emacs-lisp
  (use-package sudo-edit
    :ensure t)
#+end_src

** PDF

Display pdf in Emacs.
#+begin_src emacs-lisp
  (use-package doc-view
    :custom
    (doc-view-resolution 300)
    (doc-view-mupdf-use-svg t)
    (large-file-warning-threshold (* 150 (expt 2 20))))
#+end_src

* ORG MODE
** Set up org defaults

Adjust fill column because virtual indentation is not handled properly.
#+begin_src emacs-lisp
  (defun tl/org-indent-fill-column-advice (res)
    (cond
     ((and (boundp 'org-indent-mode) org-indent-mode)
      (- res
         (length (plist-get (text-properties-at (point))
                            'line-prefix))))
     (t res)))

  (advice-add 'current-fill-column :filter-return #'tl/org-indent-fill-column-advice)
#+end_src

Other niceties.
#+begin_src emacs-lisp
  (setq org-return-follows-link  t)                        ;; Follow the links
  (add-to-list 'auto-mode-alist '("\\.org\\'" . org-mode)) ;; Associate all org files with org mode
  (setq org-hide-emphasis-markers t)                       ;; Hide the markers because I already use colors
  (setq org-tags-column 0)                                 ;; Place tags right after the text

  ;; Remap the change priority keys to use the UP or DOWN key.
  (define-key org-mode-map (kbd "C-c <up>") 'org-priority-up)
  (define-key org-mode-map (kbd "C-c <down>") 'org-priority-down)

  ;; Open links in the same window.
  (setq org-link-frame-setup
        '((file . find-file)))

  ;; Enable indent mode.
  (setq org-indent-indentation-per-level 4)
  (setq org-list-indent-offset 2)
  (with-eval-after-load 'org
    (add-hook 'org-mode-hook 'org-indent-mode))
#+end_src

Update statistics on save.
#+begin_src emacs-lisp
  (defun tl/update-statistics-cookies-on-save ()
    (when (derived-mode-p 'org-mode)
      (org-update-statistics-cookies nil)))

  (add-hook 'before-save-hook #'tl/update-statistics-cookies-on-save)
#+end_src

Some keybindings to speed up the access to common features.
#+begin_src emacs-lisp
  (define-key global-map (kbd "C-c c") 'org-capture)
  (define-key global-map (kbd "C-c a") 'org-agenda)
  (define-key global-map (kbd "C-c t") 'org-todo)
  (define-key global-map (kbd "C-c o") 'org-open-at-point)
  (define-key global-map (kbd "C-c s") 'org-schedule)
  (define-key global-map (kbd "C-c d") 'org-deadline)
  (define-key global-map (kbd "C-c l") 'org-insert-link)
  (define-key global-map (kbd "C-c q") 'org-set-tags-command)
#+end_src

** Set up attachment system
*** Define general attachment settings

#+begin_src emacs-lisp
  (setq org-attach-id-dir tl/org-attachments-path)
  (setq org-attach-method 'mv)
  (setq org-attach-auto-tag "attach")
#+end_src

*** Set up org board to archive attachments

#+begin_src emacs-lisp
  (use-package org-board
    :ensure t
    :after org
    :config
    (setq org-board-archive-method 'wget)
    (setq org-board-default-browser 'system))
#+end_src

*** Archive current link

#+begin_src emacs-lisp
  (defun tl/org-board-archive-heading-url ()
    "If the current Org heading has a single URL in the title, archive it with org-board."
    (interactive)
    (when (org-at-heading-p)
      (let* ((title (org-get-heading t t t t))
             (url (when (string-match org-link-bracket-re title)
                    (match-string 1 title))))
        (if url
            (org-board-new url)
          (message "No URL found in heading title.")))))
#+end_src

** Set up habit system
*** Set up consistency graph

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (setq org-habit-show-habits-only-for-today nil) ;; Show habits on all relevant view, not just today's view
    (setq org-habit-graph-column 120)
    (setq org-habit-preceding-days 15)
    (setq org-habit-following-days 5))
#+end_src

*** Define a make habit command

#+begin_src emacs-lisp
  (defun tl/org-make-habit ()
    "Turn the current TODO heading into a repeating habit using .+N style repeater.
  Prompts for :TOD: (Morning, Afternoon, Evening) and :REPEAT_TO_STATE:."
    (interactive)
    (unless (org-get-todo-state)
      (user-error "Current heading is not a TODO item"))
    (let* ((current-state (org-get-todo-state))
           (date (org-read-date nil t nil "Start habit on: "))
           (interval (read-string "Repeat interval (e.g., 1d, 2w, 3m) [default: 1d]: "))
           (interval (if (string-empty-p interval) "1d" interval))
           (date-str (format-time-string (org-time-stamp-format nil t) date))
           (repeater (concat ".+" interval))
           (tod-options '("" "Morning" "Afternoon" "Evening"))
           (tod (completing-read "Time of day (empty for none): " tod-options nil t))
           (repeat-to (completing-read
                       (format "Repeat to state (default: %s): " current-state)
                       org-todo-keywords-1 nil t nil nil current-state)))
      ;; Set only SCHEDULED with repeater
      (org-schedule nil (concat date-str " " repeater))
      (org-set-property "STYLE" "habit")
      (unless (string= repeat-to "TODO")
        (org-set-property "REPEAT_TO_STATE" repeat-to))
      (unless (string-empty-p tod)
        (org-set-property "TOD" tod))
      (message "Habit set to repeat every %s from %s, TOD: %s, returning to state: %s"
               interval date-str (if (string-empty-p tod) "unspecified" tod) repeat-to)))
#+end_src

*** Postpone habit by one day

Define postpone function.
#+begin_src emacs-lisp
  (defun tl/org-postpone-habit-by-one-day ()
    "Postpone the current habit by one day (i.e., reschedule to tomorrow)."
    (interactive)
    (unless (org-entry-get (point) "STYLE")
      (user-error "Not a habit (missing STYLE property)"))
    (save-excursion
      (let* ((current (org-get-scheduled-time (point)))
             (new (time-add current (days-to-time 1))))
        (org-schedule nil (format-time-string (org-time-stamp-format nil t) new))
        (message "Habit postponed to %s" (format-time-string "%Y-%m-%d" new)))))
#+end_src

Add similar function to org agenda.
#+begin_src emacs-lisp
  (defun tl/org-agenda-postpone-habit ()
    "Postpone the habit at point in the agenda by one day, without opening its buffer."
    (interactive)
    (let ((marker (or (org-get-at-bol 'org-hd-marker)
                      (user-error "No item at point"))))
      (save-window-excursion
        (org-with-point-at marker
          (org-with-wide-buffer
            (unless (string= (org-entry-get (point) "STYLE") "habit")
              (user-error "Not a habit"))
            (let* ((current (org-get-scheduled-time (point)))
                   (new (time-add current (days-to-time 1))))
              (org-schedule nil (format-time-string (org-time-stamp-format nil t) new))))))
      (org-agenda-redo)))

    (with-eval-after-load 'org-agenda
      (define-key org-agenda-mode-map (kbd "P") #'tl/org-agenda-postpone-habit))
#+end_src

** Set up efforts system

Make ~org-set-effort~ set current pomodoro count to 0.
#+begin_src emacs-lisp
  (defun tl/org-set-pomodoro-on-effort (&rest _)
    "Set Pomodoro to 0 if Effort was just set and Pomodoro is not yet present."
    (when (and (org-entry-get (point) "Effort") ; effort just got set
               (not (org-entry-get (point) "Pomodoro")))
      (org-entry-put (point) "Pomodoro" "0")))

  (advice-add 'org-set-effort :after #'tl/org-set-pomodoro-on-effort)
#+end_src

Increment pomodoro count instead of rescheduling if applicable.
#+begin_src emacs-lisp
  (defun tl/org-register-pomodoro ()
    "Increment the Pomodoro count for a valid repeating TODO entry.
  Works in both Org buffers and Agenda buffers."
    (interactive)
    (let ((marker (or (org-get-at-bol 'org-hd-marker)
                      (point-marker)))) ; fallback for non-agenda
      (with-current-buffer (marker-buffer marker)
        (save-excursion
          (goto-char marker)
          (unless (org-before-first-heading-p)
            (org-back-to-heading t)
            (let ((todo-state (org-get-todo-state))
                  (effort (org-entry-get (point) "Effort"))
                  (repeat (org-get-repeat)))
              (if (and todo-state effort repeat)
                  (let* ((done (string-to-number (or (org-entry-get (point) "Pomodoro") "0")))
                         (new (1+ done)))
                    (org-entry-put (point) "Pomodoro" (number-to-string new))
                    (message "Pomodoro: %d → %d" done new))
                (user-error "This entry is not a repeating TODO with Effort")))))))
    (when (derived-mode-p 'org-agenda-mode)
      (org-agenda-maybe-redo)))

  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "R") #'tl/org-register-pomodoro))
#+end_src

Set pomodoro property to 0 on repeat.
#+begin_src emacs-lisp
  (defun tl/org-reset-pomodoro-on-repeat ()
    "Reset the Pomodoro property to 0 when a repeating task is rescheduled,
  but only if the property already exists."
    (when (org-entry-get (point) "Pomodoro")
      (org-entry-put (point) "Pomodoro" "0")))

  (add-hook 'org-todo-repeat-hook #'tl/org-reset-pomodoro-on-repeat)
#+end_src

** Set up agenda
*** Set up agenda defaults.

#+begin_src emacs-lisp
  (setq org-agenda-files (list tl/org-projects-path tl/org-areas-path tl/org-resources-path))
  (setq org-agenda-window-setup 'only-window)     ;; agenda takes whole window
  (setq org-agenda-restore-windows-after-quit t)  ;; restore window configuration on exit
  (setq org-agenda-inhibit-startup nil)           ;; Ensure visibility is full
  (setq org-agenda-dim-blocked-tasks nil)         ;; Don't hide blocked subtasks
  (setq org-agenda-show-inherited-tags t)         ;; Show inherited tags (optional)
  (setq org-agenda-sticky t)                      ;; Optional: keep custom view until replaced
  (setq org-agenda-show-inherited-tags nil)       ;; Don't really use them.
  (setq org-tags-match-list-sublevels t)

  (add-hook 'org-agenda-mode-hook (lambda () (display-line-numbers-mode -1)))
#+end_src

*** Set up keybindings

#+begin_src emacs-lisp
  (with-eval-after-load 'org-agenda
    (define-key org-agenda-mode-map (kbd "j") 'org-agenda-next-item)
    (define-key org-agenda-mode-map (kbd "k") 'org-agenda-previous-item))
#+end_src

*** Set up sorting strategy

Define helper to sort tasks according to their TOD and priority.
#+begin_src emacs-lisp
  (defun tl/org-agenda-compare-by-tod (a b)
    "Compare Org agenda entries A and B by their TOD property.
  Returns -1 if A < B, +1 if A > B, nil if equal."
    (let* ((order '("Morning" "Afternoon" "Evening"))
           (get-tod (lambda (x)
                      (or (org-entry-get (get-text-property 0 'org-marker x) "TOD" t)
                          "")))
           (a-tod (funcall get-tod a))
           (b-tod (funcall get-tod b))
           (a-idx (or (cl-position a-tod order :test #'string=) (length order)))
           (b-idx (or (cl-position b-tod order :test #'string=) (length order))))
      (cond
       ((< a-idx b-idx) -1)
       ((> a-idx b-idx) +1)
       (t nil))))
#+end_src

Set up sorting strategy.
#+begin_src emacs-lisp
  (setq org-agenda-cmp-user-defined #'tl/org-agenda-compare-by-tod)

  (setq org-agenda-sorting-strategy
        '((agenda user-defined-up priority-down time-up)
        (todo user-defined-up priority-down category-keep)
        (tags user-defined-up)
        (search user-defined-up)))
#+end_src

*** Set up prefix helpers

Get title of the file where agenda item is located.
#+begin_src emacs-lisp
  (defun tl/org-get-title (&optional max-length)
    "Return the #+title of the org file corresponding to the current agenda entry.
  If MAX-LENGTH is given and the title is longer, truncate it and append '...'."
    (let* ((title (cadar (org-collect-keywords '("TITLE")))))
      (if (and max-length title (> (length title) max-length))
          (concat (substring title 0 (- max-length 3)) "...")
        title)))
#+end_src

Get the time of day as a string.
#+begin_src emacs-lisp
  (defun tl/org-get-tod-tag ()
    "Return TOD property if present and entry is a habit.
  If not a habit, return scheduled date string if scheduled.
  Otherwise, return an empty string."
    (let ((style (org-entry-get nil "STYLE"))
          (tod (org-entry-get nil "TOD" t))
          (scheduled-time (org-get-scheduled-time nil)))
      (if (and style (string= style "habit"))
          (or tod "")
        (if scheduled-time
            (format-time-string "%Y-%m-%d" scheduled-time)
          ""))))
#+end_src

Define indentation symbols.
#+begin_src emacs-lisp
  (defun tl/org-effective-level ()
    "Return the effective TODO level of the current heading.
    Effective level counts the number of TODO ancestors up to the first non-TODO heading."
    (save-excursion
      (let ((level 1)
            (done nil))
        (while (and (not done) (org-up-heading-safe))
          (if (member (org-get-todo-state) org-todo-keywords-1)
              (setq level (1+ level))
            (setq done t)))
        (when (member (org-get-todo-state) org-todo-keywords-1)
          (setq level (1+ level)))
        level)))

  (defun tl/org-agenda-indent ()
    "Return ASCII-style indent like └─ based on effective TODO level."
    (let ((level (tl/org-effective-level)))
      (if (> level 1)
          (concat (make-string (* (1- level) 2) ?\s) "└─ ")
        "  ")))
#+end_src

Define effort string.
#+begin_src emacs-lisp
  (defun tl/org-effort-string ()
    "Return a string like '1/3' showing Pomodoro progress.
  Assumes Effort is a number of pomodoros and Pomodoro is completed count."
    (let* ((effort (string-to-number (or (org-entry-get (point) "Effort") "0")))
           (done   (string-to-number (or (org-entry-get (point) "Pomodoro") "0"))))
      (if (> effort 0)
          (format "%d/%d" done effort)
        "")))
#+end_src

*** Set up indicator for body text

#+begin_src emacs-lisp
  (defun tl/org-agenda-entry-has-body-p ()
    "Return non-nil if the Org entry at point in source buffer has body text (excluding drawers)."
    (org-with-point-at (org-get-at-bol 'org-hd-marker)
      (save-excursion
        (org-back-to-heading t)
        (let ((end (save-excursion (org-end-of-subtree t t)))
              found)
          (forward-line)
          (while (and (not found) (< (point) end))
            (cond
             ;; Skip over drawers entirely
             ((looking-at org-drawer-regexp)
              (org-forward-element))  ;; skip drawer
             ;; Skip planning lines (like DEADLINE or SCHEDULED)
             ((looking-at org-planning-line-re)
              (forward-line))
             ;; Skip empty lines
             ((looking-at-p "^\\s-*$")
              (forward-line))
             ;; Found a meaningful line
             (t
              (setq found t))))
          found))))

  (defun tl/org-agenda-annotate-body-indicator ()
    "Append ! to agenda lines that have body content."
    (save-excursion
      (goto-char (point-min))
      (while (not (eobp))
        (let ((marker (get-text-property (point) 'org-hd-marker)))
          (when (and marker (tl/org-agenda-entry-has-body-p))
            (end-of-line)
            (insert " [...]")))
        (org-agenda-next-line))))

  (add-hook 'org-agenda-finalize-hook #'tl/org-agenda-annotate-body-indicator)
#+end_src

*** Set up custom prefix for agenda items

Agenda prefix format.
#+begin_src emacs-lisp
  (defvar tl/org-agenda-custom-format
     "  %-12c  ┆  %-35(tl/org-get-title 30)  ┆  %-10(tl/org-get-tod-tag)  ┆  %-3(tl/org-effort-string)  ┆  %(tl/org-agenda-indent)")

  (setq org-agenda-prefix-format
        `((agenda . ,tl/org-agenda-custom-format)
          (todo   . ,tl/org-agenda-custom-format)
          (tags   . ,tl/org-agenda-custom-format)
          (search . ,tl/org-agenda-custom-format)))
#+end_src

*** Set up org super agenda views and filters

Enable super agenda.
#+begin_src emacs-lisp
  (use-package org-super-agenda
    :ensure t
    :config
    (org-super-agenda-mode t))
#+end_src

Today's view
#+begin_src emacs-lisp
  (defvar tl/org-agenda-todays-view
    '(
      ;; Show habits and tasks.
      (agenda "" ((org-agenda-overriding-header "HABITS")
                (org-agenda-span 'day)
                (org-super-agenda-groups
                   '(;; Habits
                     (:name "Morning"
                            :property ("TOD" "Morning")
                            :order 1)
                     (:name "Afternoon"
                            :property ("TOD" "Afternoon")
                            :order 2)
                     (:name "Evening"
                            :property ("TOD" "Evening")
                            :order 3)
                     ;; Other groups go here.
                     (:discard (:anything t))
                     ))))
      ;; Show all daily tasks.
      (todo "" ((org-agenda-overriding-header "TASKS")
                (org-super-agenda-groups
                   '(;; Projects
                     (:discard (:habit t))
                     (:name "One-off tasks"
                            :and (:category ("area" "project") :todo "TODO" :not (:scheduled future))
                            :order 1)
                     (:name "Waiting"
                            :and (:category ("area" "project") :todo "WAIT")
                            :order 2)
                     (:name "Upcoming"
                            :scheduled future
                            :order 3)
                     ;; Discard everything else.
                     (:discard (:anything t))
                     ;; Other groups go here.
                     ))))
      ;; Other sections go here.
      ))
#+end_src

Resources view
#+begin_src emacs-lisp
  (defvar tl/org-agenda-resources-view
    '(
      ;; Show habits and tasks.
      (agenda "" ((org-agenda-overriding-header "AGENDA")
                (org-agenda-span 'day)
                (org-super-agenda-groups
                   '(;; Habits
                     (:discard (:property "TOD"))
                     (:discard (:not (:category "project")))
                     (:name "Active Projects"
                            :scheduled today
                            :scheduled past
                            :order 4)
                     ;; Other groups go here.
                     (:discard (:anything t))
                     ))))
      ;; Show tasks from projects I'm currently working in.
      (alltodo "" ((org-agenda-overriding-header "RESOURCES")
                   (org-super-agenda-groups
                    '(;; Projects
                      (:name "Active resources"
                             :and (:category "resource" :todo ("STARTED" "PAUSED" "NEXT"))
                             :order 1)
                      ;; Discard everything else.
                      (:discard (:anything t))
                      ;; Other groups go here.
                      ))))
      ;; Other sections go here.
      ))
#+end_src

Agenda views and filters.
#+begin_src emacs-lisp
  (setq org-agenda-custom-commands
        `(("d" "Today" ,tl/org-agenda-todays-view)
          ("r" "Resources" ,tl/org-agenda-resources-view)))
#+end_src

** Set up TODO states and transitions
*** Define permitted TODO states

#+begin_src emacs-lisp
  ;; Disable greying out DONE headlines.
  (setq org-fontify-done-headline nil)

  ;; Define default TODO states. Per-buffer settings will be set in the file header when required.
  (setq org-todo-keywords
        '((sequence
           "TODO(t)"
           "PROJECT(r)"
  	 "NEXT(n!)"
  	 "STARTED(s!)"
  	 "PAUSED(p!)"
  	 "WAIT(w!)"
  	 "SOMEDAY(s!)"
  	 "|"
  	 "DONE(d!)"
           "CANCELLED(c@)")))

  (setq org-log-into-drawer t) ;; Put state changes with timestamps into the drawer.
  (setq org-log-done nil)      ;; The output doesn't go into drawer so I just disable it.

  ;; Set faces for some TODO states.
  (setq org-todo-keyword-faces
        '(("PROJECT" . "#8959a8")
          ("NEXT" . "#c82829")
          ("STARTED" . "#f5871f")
          ("PAUSED" . "#eab700")
          ("WAIT" . "#d08770")
          ("SOMEDAY" . "#4271ae")
          ("CANCELLED" . "#eab700")))

  (setq org-enforce-todo-dependencies t)
#+end_src

*** Define parent promotion when child changed to NEXT

#+begin_src emacs-lisp
  (defun tl/org-promote-parent-if-child-progresses ()
    "If current heading switches to NEXT, update parent to STARTED if it's TODO or PROJECT."
    (when (and (equal org-state "NEXT")
               (org-up-heading-safe))
      (let ((parent-state (org-get-todo-state)))
        (when (member parent-state '("TODO" "PROJECT"))
          (org-todo "STARTED")))))

  (add-hook 'org-after-todo-state-change-hook
            #'tl/org-promote-parent-if-child-progresses)
#+end_src

*** Mark parent as DONE when all children are in a done state

#+begin_src emacs-lisp :tangle no
  (defun tl/org-mark-parent-done-if-children-complete ()
    "If all children of a heading are done, mark the parent DONE (if it's a TODO-type)."
    (when (and (string= org-state "DONE") (org-up-heading-safe))
      (let ((parent-pos (point)))
        (save-excursion
          (let ((all-done
                 (not (org-map-entries
                       (lambda ()
                         (let ((s (org-get-todo-state)))
                           (and s (not (member s org-done-keywords)))))
                       nil
                       'tree))))
            (when all-done
              (goto-char parent-pos)
              (let ((state (org-get-todo-state)))
                (when (and state (member state org-not-done-keywords))
                  (org-todo "DONE")))))))))

  (add-hook 'org-after-todo-state-change-hook
            #'tl/org-mark-parent-done-if-children-complete)
#+end_src

*** Mark entry DONE when all its children are DONE

#+begin_src emacs-lisp
  (defun org-summary-todo (n-done n-not-done)
    "Switch entry to DONE when all subentries are done, to TODO otherwise."
    (let (org-log-done org-log-states)   ; turn off logging
      (org-todo (if (= n-not-done 0) "DONE" "TODO"))))

  (add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+end_src

*** Promote next sibling to NEXT when the current one is set to DONE

#+begin_src emacs-lisp
  (defun tl/org-promote-next-sibling-when-done ()
    "When a heading is marked DONE, promote the next sibling or its first child to NEXT.

  If the next sibling is a TODO and not a habit:
  - If it has no children, promote it to NEXT.
  - If it has children, promote its first child to NEXT (assumes it's a TODO)."
    (when (string= org-state "DONE")
      (save-excursion
        (let ((pos (point)))
          (when (org-get-next-sibling)
            (let ((next-state (org-get-todo-state))
                  (style (org-entry-get nil "STYLE")))
              (unless (and style (string= style "habit"))
                (save-excursion
                  (if (org-goto-first-child)
                      ;; Has children: promote first child
                      (org-todo "NEXT")
                    ;; No children: promote sibling
                    (when (and next-state (string= next-state "TODO"))
                      (org-todo "NEXT")))))))
          (goto-char pos)))))

  (add-hook 'org-after-todo-state-change-hook
            #'tl/org-promote-next-sibling-when-done)
#+end_src

*** Write an entry to the current journal when task is chaned from PROJECT to STARTED

#+begin_src emacs-lisp
  (defun tl/get-description-at-point ()
    (interactive)
    (let ((link (org-element-context)))
      (message "%s" (buffer-substring (org-element-property :contents-begin link)
                                      (org-element-property :contents-end link)))))

  (defun tl/org-log-started-task-in-journal ()
    "When a TODO changes from PROJECT to STARTED, log a line in today's journal."
    (when (and (string= org-state "STARTED")
               (string= org-last-state "PROJECT"))
      (let* ((source-file buffer-file-name)
             (link-description (tl/get-description-at-point))
             (journal-file (denote-journal-path-to-new-or-existing-entry)))
        (with-current-buffer (find-file-noselect journal-file)
          (goto-char (point-min))
          (re-search-forward "^\\* ACTIVITY LOG")
          (org-end-of-subtree t nil)
          (unless (bolp) (insert "\n"))
          (insert "** Working on ")
          (denote-link source-file nil link-description)
          (insert "\n")
          (save-buffer)))))

  (add-hook 'org-after-todo-state-change-hook #'tl/org-log-started-task-in-journal)
#+end_src

** Set up GTD system
*** Capturing

First, let's set up task capture system.
#+begin_src emacs-lisp
  (setq org-capture-templates
        `(("i" "Inbox task" entry
           (file ,(expand-file-name "inbox.org" tl/org-path))
           "* %^{Task}  "  ;; prompt in minibuffer
           :immediate-finish t
           :kill-buffer t)))
#+end_src

Second, let's add a shortcut to quickly capture to inbox.
#+begin_src emacs-lisp
  (defun tl/org-capture-inbox ()
    (interactive)
    (call-interactively 'org-store-link)
    (org-capture nil "i"))

  (define-key global-map (kbd "C-c i") 'tl/org-capture-inbox)
#+end_src

*** Clarifying

Clarifying works by refiling inbox tasks into categories like areas, skills, or goals.
#+begin_src emacs-lisp
  (defun tl/refile-from-inbox ()
    "Refile current task to a selected heading in an area, skill, or goal file.
    The task is inserted as a sibling under the selected heading using `org-refile`,
    set to TODO, and the destination is opened after the operation."
    (interactive)
    (let* ((base-dir tl/org-path)
           (category (completing-read "Refile to: " '("areas" "projects")))
           (target-dir (expand-file-name category base-dir))
           (org-files (directory-files target-dir t "\\.org$"))
           ;; Map file title → file path
           (file-alist
            (mapcar (lambda (file)
                      (with-temp-buffer
                        (insert-file-contents file nil 0 1024)
                        (let ((title (when (re-search-forward "^#\\+title:[ \t]*\\(.*\\)$" nil t)
                                       (match-string 1))))
                          (cons (or title (file-name-nondirectory file)) file))))
                    org-files))
           (file-title (completing-read "Choose file: " (mapcar #'car file-alist)))
           (target-file (cdr (assoc file-title file-alist)))
           ;; Extract headings
           (targets
            (with-temp-buffer
              (insert-file-contents target-file)
              (org-mode)
              (let ((org-refile-targets `((,target-file :maxlevel . 9))))
                (org-refile-get-targets))))
           (target-heading (completing-read "Choose heading: "
                                            (mapcar (lambda (target) (car target)) targets)))
           ;; Set refile location
           (refile-target (assoc target-heading targets)))

      ;; Mark current task TODO
      (org-todo "TODO")

      ;; Perform the refile
      (let ((org-reverse-note-order t))
        (org-refile nil nil
                    (list (car refile-target)
                          (nth 1 refile-target)    ;; file
                          nil                      ;; position
                          (nth 3 refile-target)))) ;; marker

      ;; Save both source and destination buffers
      (let ((dest-buffer (find-buffer-visiting (nth 1 refile-target))))
        (when dest-buffer
        (with-current-buffer dest-buffer
          (save-buffer)))
        (save-buffer))  ;; save source buffer

      ;; Jump to destination
      (org-refile-goto-last-stored)))
#+end_src

** QoL improvements
*** ~toc-org~: Add table of contents

Auto-generate ToC for org files.
#+begin_src emacs-lisp
  (use-package toc-org
    :ensure t
    :init (add-hook 'org-mode-hook 'toc-org-mode))
#+end_src

*** ~org-auto-tangle~: Enable autotangle

This is a QoL feature that makes it almost unnecessary to reload Emacs during configuration process. Now all you
need to do is just reload config, becase tangled file will already be there.
#+begin_src emacs-lisp
  (use-package org-auto-tangle
    :ensure t
    :hook (org-mode-hook . org-auto-tangle-mode))
#+end_src

*** ~org-superstar~: Use beautiful bullets

Org-superstar gives us attractive bullets rather than asterisks.
#+begin_src emacs-lisp
  (use-package org-superstar
    :ensure t
    :hook (org-mode-hook . (lambda () (org-superstar-mode 1)))
    :config
    (setq org-hide-leading-stars nil)
    (setq org-superstar-leading-bullet ?\s)
    (setq org-superstar-remove-leading-stars nil)
    (setq org-superstar-headline-bullets-list
  	'("☶" "☵" "☴" "☳" "☲" "☱" "☰")))
#+end_src

*** ~org-autolist~: Automatic lists

Enable autoamtic list item or checkbox creation when pressing RET.
#+begin_src emacs-lisp
  (use-package org-autolist
    :ensure t
    :hook (org-mode-hook . org-autolist-mode))
#+end_src

*** ~org-tempo~: Block tag expansion

Org-tempo is not a separate package but a module within org that can be enabled. Org-tempo allows for '<s'
followed by TAB to expand to a begin_src tag. Other expansions available include:

| Typing the below + TAB | Expands to ...                          |
|------------------------+-----------------------------------------|
| <a                     | '#+BEGIN_EXPORT ascii' … '#+END_EXPORT  |
| <c                     | '#+BEGIN_CENTER' … '#+END_CENTER'       |
| <C                     | '#+BEGIN_COMMENT' … '#+END_COMMENT'     |
| <e                     | '#+BEGIN_EXAMPLE' … '#+END_EXAMPLE'     |
| <E                     | '#+BEGIN_EXPORT' … '#+END_EXPORT'       |
| <h                     | '#+BEGIN_EXPORT html' … '#+END_EXPORT'  |
| <l                     | '#+BEGIN_EXPORT latex' … '#+END_EXPORT' |
| <q                     | '#+BEGIN_QUOTE' … '#+END_QUOTE'         |
| <s                     | '#+BEGIN_SRC' … '#+END_SRC'             |
| <v                     | '#+BEGIN_VERSE' … '#+END_VERSE'         |
|------------------------+-----------------------------------------|
| <el                    | '#+BEGIN_SRC emacs-lisp … '#+END_SRC    |
| <cl                    | '#+BEGIN_SRC clojure … '#+END_SRC       |

#+begin_src emacs-lisp
  (with-eval-after-load 'org
    (require 'org-tempo)
    (add-to-list 'org-structure-template-alist '("el" . "src emacs-lisp"))
    (add-to-list 'org-structure-template-alist '("cl" . "src clojure")))
#+end_src

*** ~org-tidy~: Hide property drawers

Hide property drawers on items.
#+begin_src emacs-lisp
  (use-package org-tidy
    :ensure t
    :hook (org-mode-hook . org-tidy-mode))
#+end_src

*** ~org-auto-expand~: Auto expand headings

Automatically expand specified headings.
#+begin_src emacs-lisp
  (use-package org-auto-expand
    :ensure t
    :config
    (org-auto-expand-mode))
#+end_src

* SHELLS & TERMINALS

For the sake of purity, we will be using only Eshell. For serious shell work I have ghostty installed separately.
#+begin_src emacs-lisp
  (use-package eshell-syntax-highlighting
    :ensure t
    :after esh-mode
    :hook (eshell-mode-hook . (lambda () (setenv "TERM" "xterm-256color")))
    :config
    (eshell-syntax-highlighting-global-mode +1)
    (setq eshell-rc-script (concat user-emacs-directory "eshell/profile")
          eshell-aliases-file (concat user-emacs-directory "eshell/aliases")
  	eshell-history-size 5000
  	eshell-buffer-maximum-lines 5000
  	eshell-hist-ignoredups t
  	eshell-scroll-to-bottom-on-input t
          eshell-destroy-buffer-when-process-dies t))
#+end_src

* THEMING

Making Emacs less bland.
#+begin_src emacs-lisp
  (use-package doom-themes
    :ensure t
    :config

    ;; No bold, but italic is ok.
    (setq doom-themes-enable-bold nil
          doom-themes-enable-italic nil)

    ;; Corrects (and improves) org-mode's native fontification.
    (doom-themes-org-config)
    (load-theme 'doom-tomorrow-day :noconfirm)

    ;; Disable bold globally except for bold in text.
    (mapc
     (lambda (face)
       (set-face-attribute face nil :weight 'light :bold nil :italic nil))
     (face-list))

    ;; Set colors for some specifics faces.
    (set-face-attribute 'org-code nil :foreground "#d08770")
    (set-face-attribute 'org-special-keyword nil :foreground "#d08770")
    (set-face-attribute 'org-drawer nil :foreground "#d08770")
    (set-face-attribute 'bold nil :foreground "#8959a8")
    (set-face-attribute 'italic nil :foreground "#eab700"))
#+end_src

** Defining font faces

Defining the various fonts that Emacs will use.
#+begin_src emacs-lisp
  (set-face-attribute 'default nil
    :font "AporeticSerifMono Nerd Font"
    :height 160
    :weight 'light)
  (set-face-attribute 'variable-pitch nil
    :font "AporeticSerifMono Nerd Font"
    :height 160
    :weight 'light)
  (set-face-attribute 'fixed-pitch nil
    :font "AporeticSerifMono Nerd Font"
    :height 160
    :weight 'light)

  ;; Makes commented text italics.
  (set-face-attribute 'font-lock-comment-face nil
    :slant 'italic)

  ;; Adjust line spacing.
  (setq default-text-properties '(line-spacing 0.20 line-height 1.20))
  (setq-default cursor-type '(hbar . 17))
#+end_src

** Zooming in/out

You can use the bindings CTRL plus =/- for zooming in/out. You can also use CTRL plus the mouse wheel for zooming
in/out.
#+begin_src emacs-lisp
  (global-set-key (kbd "C-M-=") 'text-scale-increase)
  (global-set-key (kbd "C-M--") 'text-scale-decrease)
  (global-set-key (kbd "<C-wheel-up>") 'text-scale-increase)
  (global-set-key (kbd "<C-wheel-down>") 'text-scale-decrease)
#+end_src

** Adding icons

Adding icons to Emacs.
#+begin_src emacs-lisp
  (use-package nerd-icons
    :ensure t)
  ;; ibuffer
  (use-package nerd-icons-ibuffer
    :ensure t
    :after nerd-icons
    :config
    (add-hook 'ibuffer-mode-hook #'nerd-icons-ibuffer-mode))
  ;; dired
  (use-package nerd-icons-dired
    :ensure t
    :after nerd-icons
    :config
    (add-hook 'dired-mode-hook #'nerd-icons-dired-mode))
  ;; Completions
  (use-package nerd-icons-completion
    :ensure t
    :config
    (nerd-icons-completion-mode))
#+end_src

* USER INTERFACE
** Dashboard

Add some usefullness on startup.
#+begin_src emacs-lisp
  (use-package dashboard
    :ensure t
    :after nerd-icons
    :config
    (setq dashboard-center-content t
          dashboard-vertically-center-content t
          dashboard-vertically-center-content t
          dashboard-icon-type 'nerd-icons)
    (setq dashboard-startupify-list
  	'(dashboard-insert-banner-title
            dashboard-insert-newline
            dashboard-insert-navigator
            dashboard-insert-newline
            dashboard-insert-init-info
            dashboard-insert-items))
    (setq dashboard-week-agenda nil)
    (add-hook 'elpaca-after-init-hook #'dashboard-insert-startupify-lists)
    (add-hook 'elpaca-after-init-hook #'dashboard-initialize)
    (dashboard-setup-startup-hook))
#+end_src

** Modeline

A minimalistic modeline. The Doom one is nicer, but I prefer the UI to be reasonably minimal.
#+begin_src emacs-lisp
  (use-package mood-line
    :ensure t
    :config (mood-line-mode))
#+end_src

** Which key

In Emacs 30, which-key was integrated into Emacs as a minor mode. We don't need to use use-package here, and almost all
config remains the same as it was with separate package.
#+begin_src emacs-lisp
  (setq which-key-sort-order #'which-key-key-order-alpha
        which-key-sort-uppercase-first nil
        which-key-add-column-padding 1
        which-key-max-display-columns nil
        which-key-min-display-lines 6
        which-key-side-window-slot -10
        which-key-side-window-max-height 0.25
        which-key-idle-delay 0.0
        which-key-max-description-length 25
        which-key-allow-imprecise-window-fit t
        which-key-separator " → ")
  (which-key-mode 1)
  (which-key-setup-side-window-bottom)

  ;; Fix which-key overlapping with minibuffer
  (defun fix-which-key--show-popup (orig-fn act-popup-dim)
    (let ((height (car act-popup-dim))
          (width  (cdr act-popup-dim)))
      (funcall orig-fn (cons (+ height 2) width))))
  (advice-add 'which-key--show-popup :around #'fix-which-key--show-popup)
#+end_src
